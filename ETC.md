Etc

<details>
<summary>✍️ 1. 동기와 비동기, 블로킹 IO와 논블로킹 IO에 대해서 설명해주세요.</summary>
<br>

***동기와 비동기***

동기와 비동기를 구분하는 기준은 작업 순서입니다.

A, B, C 순서대로 작업을 요청했는데 응답에서 그 순서가 지켜진다면 동기입니다.

반면에 비동기는 A, B, C 순서대로 작업을 요청했어도 그 순서가 지켜진다고 보장할 수 없습니다.

또한, 동기와 비동기를 시간적인 측면에서 바라봤을 때 두 개 이상의 작업이 시간을 일치하는지 하지 않는지로 해석할 수 있습니다.

메서드의 리턴 시간과 결과를 전달 받는 시간이 일치하거나 A가 끝나는 시간과 B가 시작하는 시간이 같으면 동기라고 할 수 있습니다.

***블로킹 IO와 논블로킹 IO***

블로킹과 논블로킹은 직접 제어할 수 없는 대상을 언급할 때 함께 이야기할 수 있습니다.

대상이 제한적이고 블로킹과 논블로킹을 구분하는 기준은 대기 여부입니다.

블로킹은 다른 작업이 완료될 때까지 대기하고 논블로킹은 작업의 완료 여부와 관계없이 새로운 작업을 수행할 수 있고 나중에 결과를 확인 받습니다.

많은 종류의 소프트웨어에서 동기 처리 방식이 블로킹이고 비동기 처리 방식이 논블로킹인 이유는 익숙한 구조이기 때문입니다.

일련의 작업들에 대해 순차적으로 하나씩 처리하고 완료하는 방식은 블로킹하는 게 작업의 순서를 보장하기 쉬우며 여러 작업들이 일어나는 구조에서는 한 작업을 수행하는 동시에 논블로킹으로 다른 작업을 처리하는 구조가
효율적입니다.

***코드 예시***

```
ExecutorService es = Executors.newCachedThreadPool();

String res = es.submit(() -> "Hello Async").get();
```

es.submit

- 비동기
    - 메서드의 리턴 시간과 Callable의 실행 결과를 받는 시간이 일치하지 않음
    - 기다리는 대상이 없기 때문에 블로킹, 논블로킹은 고려할 대상이 아님

get

- 동기/블로킹
    - 메서드의 리턴 시간과 결과를 가져오는 시간이 일치
    - 다른 쓰레드의 작업이 완료될 때까지 대기

</details>
