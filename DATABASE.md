Database

<details>
<summary>✍️ 1. RDBMS에서 지원하는 Transcation의 ACID에 대해서 아시나요?</summary>
<br>

ACID는 데이터베이스 트랜잭션을 보장하기 위한 성질입니다.

트랜잭션이란 여러개의 작업을 하나로 묶은 일련의 실행 단위 또는 데이터에 대한 하나의 논리적 실행 단계를 의미합니다.

만약 트랜잭션에서 속한 여러 작업 중 하나의 작업이라도 실패하는 경우 트랜잭션이 실패한 것으로 간주합니다.

- 원자성
    - 트랜잭션에 속한 모든 작업이 전부 성공하거나 전부 실패해서 결과를 예측할 수 있도록 하는 것입니다.
        - 보내는 쪽에서 출금하는 작업만 성공하고 받는 쪽에서 입금하는 작업을 실패해서는 안 됩니다.
- 일관성
    - 트랜잭션 이후의 데이터베이스 상태는 이전과 같이 일관되게 유지하는 것입니다.
        - 계좌이체 후 전체 계좌 잔고의 총합은 이전과 동일해야 합니다.
- 고립성
    - 트랜잭션은 다른 트랜잭션으로부터 독립적으로 동작되도록 하는 것입니다.
        - 동시에 여러개의 트랜잭션이 실행되는 경우 각 트랜잭션은 고립되어 있어서 연속적으로 실행된 것과 같은 결과를 가질 수 있습니다.
- 지속성
    - 성공적으로 실행된 트랜잭션은 영원히 데이터베이스에 반영하는 것입니다.
        - 오류가 발생하여 로그를 남기는데 실패하게 되면 해당 트랜잭션은 실패로 간주하고 취소됩니다.

ACID는 데이터베이스의 모든 연산이 한번에 실행되는 것을 권장합니다.

널리 사용하는 방법으로는 로깅과 새도우 페이징이 있고 두 경우 모두 업데이트 되는 데이터에 락을 거는 것이 필요합니다.

로깅에서 원자성은 데이터를 업데이트 하기 전에 로그에 모든 변경사항을 기록하는 것으로 보장합니다. 이것은 충돌 현상이 발생하더라도 데이터베이스의 무결성을 보장해줍니다.

새도우 페이징은 데이터의 변경이 복사본에 저장됩니다. 새로운 복사본은 트랜잭션이 커밋되면 활성화되고 복사본은 변경 전 데이터 부분만을 의미합니다.

ACID를 보장하기 위해 락에 의존하는 것은 동시작업 실행이 어렵고 성능저하를 초래할 수도 있습니다.

</details>

<details>
<summary>✍️ 2. 인덱스는 왜 사용하는 것인가요?</summary>
<br>

검색 성능을 향상시키기 위해 사용합니다.

테이블에 많은 열이 포함되어 있거나 대량의 데이터가 저장되어 있는 경우 테이블에서 특정 데이터를 검색하려고 하면 많은 시간이 걸릴 수 있습니다. 이런 경우에는 적절한 컬럼에 인덱스를 생성하면 검색이 빨라질 수
있습니다.

***인덱스***

데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조

특정 컬럼에 인덱스를 생성하면 인덱스를 위한 별도의 메모리 공간에 데이터가 물리적 주소와 함께 저장됩니다.

인덱스에 저장된 데이터의 물리적 주소를 참조하여 데이터를 찾기 때문에 검색 속도가 향상됩니다.

***장점***

- 테이블 조회 속도 향상
    - 테이블의 데이터는 인덱스를 기준으로 정렬되어 있기 때문에 조건 검색 시 장점을 가집니다.
        - 조건 검색 WHERE 절의 효율성
            - 인덱스를 사용하지 않으면 조건 검색 시에 풀 테이블 스캔을 해야 합니다.
        - 정렬 ORDER BY 절의 효율성
            - 인덱스를 사용하면 ORDER BY에 의한 정렬 과정을 생략할 수 있습니다.
            - ORDER BY 작업은 1차적으로 메모리에서 정렬을 하고 메모리보다 큰 작업은 디스크 I/O를 통해 정렬을 하는 무거운 작업입니다.
        - MAX, MIN의 효율적 처리
            - MAX 작업 시 컬럼의 마지막 값을 가져오면 되고 MIN 작업 시 컬럼의 시작 값을 가지고 오면 됩니다.
            - 풀 테이블 스캔을 할 필요가 없습니다.

***단점***

- 인덱스 관리(정렬된 상태 유지)를 위한 추가적인 작업이 필요합니다.
    - 인덱스가 적용된 컬럼에
        - INSERT가 발생하면 새로운 데이터에 대한 인덱스를 추가하는 작업이 필요합니다.
        - DELETE가 발생하면 삭제하는 데이터의 인덱스를 사용하지 않음 처리하는 작업이 필요합니다.
        - UPDATE가 발생하면 기존 인덱스를 사용하지 않음 처리하고 변경된 데이터에 대한 인덱스를 추가하는 작업이 필요합니다.
- 테이블의 10~15% 이하의 데이터를 처리하는 경우에만 효율적입니다.
    - 인덱스를 관리하기 위해 데이터베이스의 10% 정도의 추가 저장공간이 필요합니다.
- 인덱스를 잘못 관리하면 오히려 성능이 저하됩니다.
    - CREATE, DELETE, UPDATE가 빈번한 컬럼에 인덱스를 생성하게 되면 인덱스의 크키가 비대해져서 오히려 성능이 저하됩니다.

***생성 전략***

인덱스를 생성한다고 해서 무조건 속도가 빨라지는 것은 아니기 때문에 적절한 컬럼을 선택해서 인덱스를 생성해야 합니다.

- Cardinality
  - 특정 데이터 집합의 유일한 값의 개수
    - 전체 행에 대한 특정 컬럼의 데이터 중복 수치에 대한 정보를 Cardinality라고 합니다.
      - 중복되는 횟수가 높으면 Cardinality 값이 낮고 중복되는 횟수가 낮으면 Cardinality 값이 높다고 표현합니다.
        - Cardinality 값이 높은 컬럼을 인덱스로 생성했을 때 성능이 좋습니다.
- Selectivity
  - 데이터 집합에서 특정 값을 얼마나 잘 선택할 수 있는지에 대한 지표
    - Selectivity = Cardinality / Total Number Of Records
      - Selectivity 값이 1이라는 의미는 모든 컬럼의 값이 유일하다는 의미입니다.
        - Selectivity 값이 높은 컬럼을 인덱스로 생성했을 때 조회 성능이 좋습니다.
</details>
